import numpy as N

from tracer.surface import *
from tracer.quadric import *
from tracer.cone import *
from tracer.cylinder import *
from tracer.flat_surface import *
from tracer.assembly import *
from tracer.optics_callables import *
from tracer.object import *
from tracer.spatial_geometry import *
from tracer.sources import *
from tracer.tracer_engine import *
from tracer.CoIn_rendering.rendering import *

import time

class RTVF():
	'''
	General class for view factor raytraces.
	num_rays - number of rays fired per bundle
	precision - confidence interval threshold on view factor values for each element and for the combination rule between all elements of the scene.
	'''
	def __init__(self, num_rays=5000, precision=1e-2):
		self.num_rays = num_rays
		self.precision = precision
		# Standard deviation computation variables.
		self.VF_esperance = 0.
		self.Qsum = 0.
		self.VF_reciprocity = 0.
				
	def reset_opt(self):
		'''
		Optics reset script to be able to raytrace again the same object without having energy already stored on the surfaces.
		'''
		S = self.A.get_surfaces()
		for i in xrange(len(S)):
			S[i].get_optics_manager().reset()

	
	def test_precision(self):
		'''
		Routine that gathers the results of the VF binning after a full geometry reaytrace and checks the standard deviations of: 
		1. The value of the actual VF_estimator (passes averaged VF) to check each VF matrix element on its independent variation
		2. The combination rule; taking as arbitrary average 0 in the standard deviation formula.
		Afterwards both standard deviation matrices are tested on the maximum self.precision value and the result is inserted in the progress matrix used in the while loop for each geometry. This progress matrix shuts off the raytrace on elements that already hit their precision target in order to speed up teh calculation. A minimum number of iterations is set in order to avoid unlucky breacks at the start of the routine due to statistical bias on low number of passes.
		'''

		test = self.test
		progress = self.progress
		areas = self.areas
		precision = self.precision
		self.VF_esperance = (self.VF_esperance*self.p+self.VF)/(self.p+1.)
		rec = N.vstack(areas)*self.VF_esperance
		self.VF_reciprocity = (rec-rec.T)**2.
		self.Qsum = (self.Qsum*self.p+(self.VF-self.VF_esperance)**2.)/(self.p+1.)
		if self.p>0.:
			stdev_VF = N.sqrt(self.Qsum/self.p)
			stdev_reciprocity = N.sqrt(self.VF_reciprocity/self.p)
			stdev_test = stdev_VF<precision
			reciprocity_test = N.logical_and(stdev_reciprocity<precision, stdev_reciprocity.T<precision)
			self.progress = N.logical_not(N.logical_and(stdev_test, reciprocity_test))



class Cylinder_cavity_RTVF(RTVF):
	'''
	General class for cylindrical cavities view factors calculations.
	'''
	def __init__(self, ra, rc, lcs, num_rays, precision):
		'''
		ra  - radius of the aperture
		rc - radius of the cylinder
		lcs -  array with the lenght of each element of cylinder section to use as an axisymmetrical view factor element bin.
		'''
		RTVF.__init__(self, num_rays, precision)
		self.ra = float(ra)
		self.rc = float(rc)
		self.lcs = N.asarray(lcs, dtype=float)	

		# Identify if the aperture radius is smalle than the cylinder radius to add a pierced disc element to the geometry when declaring it:
		if ra==rc:
			VF = N.zeros((2+len(lcs), 2+len(lcs)))
			cyl=1
		else:
			VF = N.zeros((3+len(lcs), 3+len(lcs)))
			cyl=2

		self.VF = VF
		self.test = N.zeros(N.shape(VF)) # Used for the combination rule test.
		self.progress = N.ones(N.shape(VF)) # this is the array that detects if the element has to be ray-traced again or if engough precision has been obtained on it already.
		areas = N.zeros(N.shape(VF)[0])
		areas[0] = N.pi*ra**2
		if ra!=rc:
			areas[1] = N.pi*(rc**2-ra**2)
		areas[cyl:-1] = 2*N.pi*rc*self.lcs
		areas[-1] = N.pi*rc**2
		self.areas=areas

		# Build the scene:
		A = Assembly()
		# Aperture
		AP = AssembledObject(surfs=[Surface(RoundPlateGM(Re=ra), ReflectiveReceiver(1.))], transform = None)
		A.add_object(AP)
		self.AP = AP
		# Aperture cover (if any)
		if ra!=rc:
			AP_cov = AssembledObject(surfs=[Surface(RoundPlateGM(Ri=ra,Re=rc), ReflectiveReceiver(1.))], transform = None)
			A.add_object(AP_cov)
			self.AP_cov = AP_cov
		# Cylinder
		CYL = AssembledObject(surfs=[Surface(FiniteCylinder(diameter=2.*rc,height=N.sum(lcs)), ReflectiveReceiver(1.))], transform = translate(z=N.sum(lcs)/2.))
		A.add_object(CYL)
		self.CYL = CYL
		# Bottom
		BOT = AssembledObject(surfs=[Surface(RoundPlateGM(Re=rc), ReflectiveReceiver(1.))], transform = translate(z=N.sum(lcs)))
		A.add_object(BOT)
		self.BOT = BOT
		self.A = A

		vf_tracer = TracerEngine(A)
		itmax=1
		minener=0.01/self.num_rays

		# Sequentially raytrace the whole geometry, element per element until having tested all the elements one time. After that, evaluate the precision of the result for each element using the "test_precision" routine and start againg "sweeping" through the geometry. Goes on until the standard deviation, and the combination rule, of all view factor elements in the scene are below the precision threshold declared.

		self.p=0
		while (self.progress==True).any():
			print 'PASS: ',self.p
			# Aperture:
			if (self.progress[0,:]==False).all():
				self.VF[0,:] = self.VF_esperance[0,:]
			else:
				self.reset_opt()
				SA = solar_disk_bundle(num_rays, center=N.vstack([0,0,0]), direction=N.array([0,0,1]), radius=ra, ang_range=N.pi/2., flux=1./(N.pi*ra**2))
				vf_tracer.ray_tracer(SA, itmax, minener, tree = True)
				self.alloc_VF(0)
			# Aperture cover:
			if ra!=rc:
				if (self.progress[1,:]==False).all():
					self.VF[1,:] = self.VF_esperance[1,:]
				else:
					self.reset_opt()
					SAc = solar_disk_bundle(num_rays, center=N.vstack([0,0,0]), direction=N.array([0,0,1]), radius=rc, radius_in=ra, ang_range=N.pi/2., flux=1./(N.pi*(rc**2-ra**2)))
					vf_tracer.ray_tracer(SAc, itmax, minener, tree = True)
					self.alloc_VF(1)
			# Cylinder sections:
			for i in xrange(len(lcs)):
				if (self.progress[i+cyl,:]==False).all():
					self.VF[i+cyl,:] = self.VF_esperance[i+cyl,:]
					continue
				self.reset_opt()
				if i==0:
					S = vf_cylinder_bundle(num_rays, rc=rc, lc=lcs[i], center=N.vstack([0,0,0]), direction=N.array([0,0,1]), rays_in=True)
				else:
					S = vf_cylinder_bundle(num_rays, rc=rc, lc=lcs[i], center=N.vstack([0,0,N.sum(lcs[:i])]), direction=N.array([0,0,1]), rays_in=True)
				vf_tracer.ray_tracer(S, itmax, minener, tree = True)
				self.alloc_VF(cyl+i)
			# Cylinder backplate:
			if (self.progress[-1,:]==False).all():
				self.VF[-1,:] = self.VF_esperance[-1,:]
			else:
				self.reset_opt()
				SB = solar_disk_bundle(num_rays, center=N.vstack([0,0,N.sum(lcs)]), direction=N.array([0,0,-1]), radius=rc, ang_range=N.pi/2., flux=1./(N.pi*rc**2))
				vf_tracer.ray_tracer(SB, itmax, minener, tree = True)
				self.alloc_VF(cyl+len(lcs))

			self.test_precision()
			self.p+=1

	def alloc_VF(self, n):
		'''
		get hits in the scene and bin them in VF matrix.
		'''
		ra = self.ra
		rc = self.rc
		lcs = self.lcs
		Aperture_abs, Aperture_hits = self.AP.get_surfaces()[0].get_optics_manager().get_all_hits()
		Cylinder_abs, Cylinder_hits = self.CYL.get_surfaces()[0].get_optics_manager().get_all_hits()
		Bottom_abs, Bottom_hits = self.BOT.get_surfaces()[0].get_optics_manager().get_all_hits()

		self.VF[n,0] = N.sum(Aperture_abs)
		cyl=1
		if (ra != rc):
			self.VF[n,1] = N.sum(Aperture_cover_abs)
			cyl=2
		for i in xrange(len(lcs)):
			if i == 0:
				self.VF[n,cyl+i] = N.sum(Cylinder_abs[N.where(N.logical_and(Cylinder_hits[2]<=lcs[i], (Cylinder_hits[2]>0)))])
			else:			
				self.VF[n,cyl+i] = N.sum(Cylinder_abs[N.where(N.logical_and(Cylinder_hits[2]<=N.sum(lcs[:i+1]), Cylinder_hits[2]>N.sum(lcs[:i])))])
		self.VF[n,-1] = N.sum(Bottom_abs)



class Uniform_cylinder_cavity_RTVF(Cylinder_cavity_RTVF):
	'''
	Wrapper around the Cylinder_cavity _RTVF class to evenly separate the elements on the cylinder surface.
	'''
	def __init__(self, ra, rc, lc, el_CYL, num_rays, precision):
		lcs = N.ones(el_CYL)*(float(lc)/el_CYL)
		Cylinder_cavity_RTVF.__init__(self, ra, rc, lcs, num_rays, precision)



class Two_N_parameters_cavity_RTVF(RTVF):
	'''
	A class for 2N parameters axisymmetrical cavities composed of frusta and a cone.

	apertureRadius - Radius of the aperture of the geometry
	frustaRadii - List of the successive radii of the frusta, starting from the aperture and following the profile of the geometry.
	frustaDepths - List of the depths of the frusta, starting from the aperture and following the profile of the geometry.
	coneDepth - Depth of the cone to close the geometry.
	el_FRUs - A list describing the discretisation of the frusta in the scene. Each frustum [i] is discretised into el_FRUs[i] elements of equal depths.
	el_CON - The number of discretisation elements of equal depths used for the conical part of the receiver.
	'''
	def __init__(self, apertureRadius, frustaRadii, frustaDepths, coneDepth, el_FRUs, el_CON, num_rays=5000, precision=0.01):
		RTVF.__init__(self, num_rays, precision)
		self.apertureRadius = apertureRadius
		self.frustaRadii = frustaRadii
		self.frustaDepths = frustaDepths
		self.coneDepth = coneDepth
		self.el_FRUs = el_FRUs
		self.el_CON = el_CON

		t0=time.clock()

		self.VF = N.zeros((1+N.sum(el_FRUs)+el_CON, 1+N.sum(el_FRUs)+el_CON))
		self.progress = N.ones(N.shape(self.VF))
		self.test = N.zeros(N.shape(self.VF))
		areas = N.zeros(N.shape(self.VF)[0])

		if type(el_FRUs)==int:
			el_FRUs = N.asarray([el_FRUs])
			self.el_FRUs = el_FRUs
		if type(el_CON)==int:
			el_CON = N.asarray([el_CON])
			self.el_CON = el_CON

		# Areas calculations:		
		areas[0] = N.pi*apertureRadius**2 # Aperture
		if apertureRadius==frustaRadii[0]: # Cylinder
			areas[1:1+el_FRUs[0]] = N.pi*2.*frustaRadii[0]*N.sqrt((frustaDepths[0]/el_FRUs[0])**2)
		else:
			areas[1:1+el_FRUs[0]] = N.pi*(2.*apertureRadius+(2.*N.arange(el_FRUs[0])+1)*(frustaRadii[0]-apertureRadius)/el_FRUs[0])*N.sqrt((frustaDepths[0]/el_FRUs[0])**2+((frustaRadii[0]-apertureRadius)/el_FRUs[0])**2) # 1st frustum
		for k in xrange(1,len(el_FRUs)): # next frusta
			if self.frustaRadii[k-1]==self.frustaRadii[k]:
				areas[1+N.sum(el_FRUs[:k+1])-el_FRUs[k]:1+N.sum(el_FRUs[:k+1])] = 2.*N.pi*frustaRadii[k]*N.sqrt((frustaDepths[k]/el_FRUs[k])**2)
			else:
				areas[1+N.sum(el_FRUs[:k+1])-el_FRUs[k]:1+N.sum(el_FRUs[:k+1])] = N.pi*(2.*frustaRadii[k-1]+(2.*N.arange(el_FRUs[k])+1)*(frustaRadii[k]-frustaRadii[k-1])/el_FRUs[k])*N.sqrt((frustaDepths[k]/el_FRUs[k])**2+((frustaRadii[k]-frustaRadii[k-1])/el_FRUs[k])**2)

		areas[1+N.sum(el_FRUs):1+N.sum(el_FRUs)+el_CON] = N.pi*(2.*frustaRadii[-1]+(2.*N.arange(el_CON)+1)*(-frustaRadii[-1])/el_CON)*N.sqrt((coneDepth/el_CON)**2+((frustaRadii[-1]/el_CON)**2)) # Cone

		self.areas = areas

		# Build the geometry:
		A = Assembly()
		max_depth = N.sum(frustaDepths)
		# Cone section:
		if coneDepth>0.: # == cone depth > 0: Outgoing cone
			max_depth = max_depth + coneDepth
			trc = N.dot(rotx(N.pi), translate(z=-max_depth)) # Cone frame transformation
			CON = AssembledObject(surfs=[Surface(FiniteCone(r=frustaRadii[-1], h=coneDepth), LambertianReceiver(absorptivity=1))], transform=trc)
			rays_cone=True
		elif coneDepth == 0.: # Round flat plates
			CON = AssembledObject(surfs=[Surface(RoundPlateGM(Re=frustaRadii[-1]), LambertianReceiver(absorptivity=1))], transform=translate(z=max_depth))
		else: # coneDepth < 0 Inward cone
			CON = AssembledObject(surfs=[Surface(FiniteCone(r=frustaRadii[-1], h=-coneDepth), LambertianReceiver(absorptivity=1))], transform=translate(z=max_depth+coneDepth))
			rays_cone=False

		FRU = []
		# 1st frustum:
		if apertureRadius==frustaRadii[0]: # Cylinder
			frustum = AssembledObject(surfs=[Surface(FiniteCylinder(diameter=frustaRadii[0]*2., height=frustaDepths[0]), LambertianReceiver(absorptivity=1))], transform=translate(z=frustaDepths[0]/2.))
		else: # frustum
			frustum = AssembledObject(surfs=[Surface(ConicalFrustum(z1=0., r1=apertureRadius, z2=frustaDepths[0], r2=frustaRadii[0]), LambertianReceiver(absorptivity=1))], transform=None)
		FRU.append(frustum)
		# next frusta:
		for i in xrange(1,len(frustaRadii)):
			if self.frustaRadii[i-1]==self.frustaRadii[i]:
				frustum = AssembledObject(surfs=[Surface(FiniteCylinder(diameter=self.frustaRadii[i]*2., height=self.frustaDepths[i]), LambertianReceiver(absorptivity=1))], transform=translate(z=N.sum(self.frustaDepths[:i])+self.frustaDepths[i]/2.))
			elif self.frustaDepths[i] < 0.:
				frustum = AssembledObject(surfs=[Surface(ConicalFrustum(z1=0., r1=self.frustaRadii[i-1], z2=-self.frustaDepths[i], r2=self.frustaRadii[i]), LambertianReceiver(absorptivity=1))], transform=N.dot(translate(z=N.sum(self.frustaDepths[:i])),rotx(N.pi)))
			else:
				frustum = AssembledObject(surfs=[Surface(ConicalFrustum(z1=0., r1=self.frustaRadii[i-1], z2=self.frustaDepths[i], r2=self.frustaRadii[i]), LambertianReceiver(absorptivity=1))], transform=translate(z=N.sum(self.frustaDepths[:i])))
			FRU.append(frustum)

		A.add_object(CON)	
		for i in xrange(len(FRU)):
			A.add_object(FRU[i])

		AP = AssembledObject(surfs=[Surface(RoundPlateGM(Re=apertureRadius), LambertianReceiver(absorptivity=1))], transform = None)
		A.add_object(AP)
		self.A = A
		self.AP = AP
		self.CON = CON
		self.FRU = FRU

		vf_tracer = TracerEngine(A)
		vf_tracer.minener = 1 # stop iteration after this many ray bundles were generated (i.e. 
		itmax = 100 # after the original rays intersected some surface this many times).
		vf_tracer.engine = 0.1/num_rays # minimum energy threshold
		#view = Renderer(vf_tracer)

		self.p=0
		while (self.progress==True).any():
			tp = time.clock()
			if (self.progress[0,:]==False).all():
				self.VF[0,:] = self.VF_esperance[0,:]
			else:
				self.reset_opt()
				SA = solar_disk_bundle(num_rays, center=N.vstack([0,0,0]), direction=N.array([0,0,1]), radius=apertureRadius, ang_range=N.pi/2., flux=1./(N.pi*apertureRadius**2))

				vf_tracer.ray_tracer(SA, itmax, minener, tree = True)
				self.alloc_VF(0)

			for elf in xrange(el_FRUs[0]):
				self.reset_opt()
				if (self.progress[1+elf,:]==False).all():
					self.VF[1+elf,:] = self.VF_esperance[1+elf,:]
					continue

				if apertureRadius==frustaRadii[0]:
					S = vf_cylinder_bundle(num_rays, rc=frustaRadii[0], lc=frustaDepths[0]/el_FRUs[0], center=N.vstack([0,0,elf*frustaDepths[0]/el_FRUs[0]]), direction=N.array([0,0,1]), rays_in=True)
				else:
					S = vf_frustum_bundle(num_rays, r1=apertureRadius+elf*(frustaRadii[0]-apertureRadius)/el_FRUs[0], r2=apertureRadius+(elf+1)*(frustaRadii[0]-apertureRadius)/el_FRUs[0], depth=frustaDepths[0]/el_FRUs[0], center=N.vstack([0,0,elf*frustaDepths[0]/el_FRUs[0]]), direction=N.array([0,0,1]), rays_in=True)

				vf_tracer.ray_tracer(S, itmax, minener, tree = True)
				self.alloc_VF(elf+1)

			for n in xrange(1,len(el_FRUs)):
				for elf in xrange(el_FRUs[n]):
					self.reset_opt()
					if (self.progress[1+N.sum(el_FRUs[:n+1])-el_FRUs[n]+elf,:]==False).all():
						self.VF[1+N.sum(el_FRUs[:n+1])-el_FRUs[n]+elf,:] = self.VF_esperance[1+N.sum(el_FRUs[:n+1])-el_FRUs[n]+elf,:]
						continue
					if frustaDepths[n] <0:
						rays_in_frun = False
					else:
						rays_in_frun = True
					if frustaRadii[n-1]==frustaRadii[n]:
						S = vf_cylinder_bundle(num_rays, rc=frustaRadii[n], lc=frustaDepths[n]/el_FRUs[n], center=N.vstack([0,0,N.sum(frustaDepths[:n])+elf*frustaDepths[n]/el_FRUs[n]]), direction=N.array([0,0,1]), rays_in=rays_in_frun)
					else:
						S = vf_frustum_bundle(num_rays, r1=frustaRadii[n-1]+elf*(frustaRadii[n]-frustaRadii[n-1])/el_FRUs[n], r2=frustaRadii[n-1]+(elf+1)*(frustaRadii[n]-frustaRadii[n-1])/el_FRUs[n], depth=frustaDepths[n]/el_FRUs[n], center=N.vstack([0,0,N.sum(frustaDepths[:n])+elf*frustaDepths[n]/el_FRUs[n]]), direction=N.array([0,0,1]), rays_in=rays_in_frun)

					vf_tracer.ray_tracer(S, itmax, minener, tree = True)
					self.alloc_VF(1+N.sum(el_FRUs[:n+1])-el_FRUs[n]+elf)
				#view.show_rays()

			for elc in range(el_CON):
				self.reset_opt()
				if (self.progress[1+N.sum(el_FRUs)+elc,:]==False).all():
					self.VF[1+N.sum(el_FRUs)+elc,:] = self.VF_esperance[1+N.sum(el_FRUs)+elc,:]
					continue
				if coneDepth==0.:
					S = solar_disk_bundle(num_rays, center=N.vstack([0,0,N.sum(frustaDepths)]), direction=N.array([0,0,-1]), radius=frustaRadii[-1]+elc*(-frustaRadii[-1])/el_CON, ang_range=N.pi/2., flux=1./(N.pi*frustaRadii[-1]**2), radius_in=frustaRadii[-1]+(elc+1)*(-frustaRadii[-1])/el_CON)

				else:
					S = vf_frustum_bundle(num_rays, r1=frustaRadii[-1]+elc*(-frustaRadii[-1])/el_CON, r2=frustaRadii[-1]+(elc+1)*(-frustaRadii[-1])/el_CON, depth=coneDepth/el_CON, center=N.vstack([0,0,N.sum(frustaDepths)+coneDepth*elc/el_CON]), direction=N.array([0,0,1]), rays_in=rays_cone)

				vf_tracer.ray_tracer(S, itmax, minener, tree = True)
				self.alloc_VF(N.sum(el_FRUs)+elc+1)

			self.test_precision()
			self.p+=1
			print '		PASS:',self.p, '; Progress:', N.sum(self.progress),"; Pass duration:", time.clock()-tp, 's'

		t1=time.clock()-t0
		print '	VF calculation time:',t1,'s'

	def alloc_VF(self, n):
		'''
		get hits in the scene and bin them in VF matrix.
		'''
		apertureRadius = self.apertureRadius
		frustaRadii = self.frustaRadii
		frustaDepths = self.frustaDepths
		coneDepth = self.coneDepth
		el_FRUs = self.el_FRUs
		el_CON = self.el_CON

		# Gather hits and absorbed radiative power
		Aperture_abs, Aperture_hits = self.AP.get_surfaces()[0].get_optics_manager().get_all_hits()
		Frustum_abs = []
		Frustum_hits = []
		for i in xrange(len(el_FRUs)):
			Fru_abs, Fru_hits = self.FRU[i].get_surfaces()[0].get_optics_manager().get_all_hits()
			Frustum_abs.append(N.asarray(Fru_abs))
			Frustum_hits.append(N.asarray(Fru_hits))
		Cone_abs, Cone_hits = self.CON.get_surfaces()[0].get_optics_manager().get_all_hits()
	
		# VF allocation to a nxn VF matrix. Convention is to go from the aperture to the back of the shape following the axi-symmetric profile line. First loop is for gemoetrical shapes and second one for the discretisation of each shape.
		for j in xrange(len(el_FRUs)+2):
			if j == 0:
				self.VF[n,j] = N.sum(Aperture_abs)
			elif j <= len(el_FRUs):
				for i in xrange(el_FRUs[j-1]):
					frustum_el_base = N.sum(frustaDepths[:j])-frustaDepths[j-1]+i*frustaDepths[j-1]/el_FRUs[j-1]
					frustum_el_top = N.sum(frustaDepths[:j])-frustaDepths[j-1]+(i+1)*frustaDepths[j-1]/el_FRUs[j-1]
					if frustaDepths[j-1]<0.:
						frustum_el_base, frustum_el_top = frustum_el_top, frustum_el_base
					in_frustum_el = N.logical_and(Frustum_hits[j-1][2]>=frustum_el_base, Frustum_hits[j-1][2]<frustum_el_top)
					self.VF[n,i+1+N.sum(el_FRUs[:j])-el_FRUs[j-1]] = N.sum(Frustum_abs[j-1][in_frustum_el])
			else:
				for i in xrange(el_CON):

					r1 = frustaRadii[-1]-i*frustaRadii[-1]/el_CON
					r2 = frustaRadii[-1]-(i+1)*frustaRadii[-1]/el_CON

					cone_hits_radii = N.sqrt(Cone_hits[0]**2+Cone_hits[1]**2)
					in_cone_el = N.logical_and(cone_hits_radii<r1, cone_hits_radii>=r2)
		
					self.VF[n,i+1+N.sum(el_FRUs)] = N.sum(Cone_abs[in_cone_el])

class Four_parameters_cavity_RTVF(Two_N_parameters_cavity_RTVF):
	'''
	Wrapper around the Two_N_parameters_cavity_RTVF class to a 4 parameters cavity.
	ref: "Open cavity receiver geometry influence on radiative losses" (DOI:10.13140/2.1.3845.5048)
	'''
	def __init__(self, apertureRadius, apertureDepth, coneRadius, coneDepth, el_FRU, el_CON, num_rays, precision):
		Two_N_parameters_cavity_RTVF.__init__(self, apertureRadius, [coneRadius], [apertureDepth], coneDepth, el_FRU, el_CON, num_rays, precision)

