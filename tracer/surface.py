# Define some basic surfaces for use with the ray tracer. From this minimal 
# hierarchy other surfaces should be derived to implement actual geometric
# operations.
#
# References:
# [1] John J. Craig, Introduction to Robotics, 3rd ed., 2005. 

# All surfaces are grey.

import numpy as N
from has_frame import HasFrame

class Surface(HasFrame):
    """
    Defines the base of surfaces that interact with rays.
    """
    def __init__(self, geometry, optics, location=None, rotation=None):
        """
        Arguments:
        geometry - a GeometryManager object responsible for finding ray 
            intersections with the surface.
        optics - a callable that gets the geometry manageri, bundle and
            selector, and returns the outgoing ray bundle generated by the
            geometry and bundle.
        location, rotation - passed directly to the HasFrame constructor.
        """
        HasFrame.__init__(self, location, rotation)
        self._geom = geometry
        self._opt = optics
    
    def get_optics_manager(self):
        """
        Returns the optics-manager callable. May be useful for introspection.
        Note that it is a read-only attribute.
        """
        return self._opt
    
    def get_geometry_manager(self):
        """
        Returns the geometry-manager instance. May be useful for introspection.
        Note that it is a read-only attribute.
        """
        return self._geom
    
    def set_parent_object(self, object):
        """Describes which object the surface is in """
        self.parent_object = object

    def register_incoming(self, ray_bundle):
        """
        Records the incoming ray bundle, and uses the geometry manager to
        return the parametric positions of intersection with the surface along
        the ray.
        
        Arguments:
        ray_bundle - a RayBundle object with at-least its vertices and
            directions specified.
        
        Returns
        A 1D array with the parametric position of intersection along each of
            the rays. Rays that missed the surface return +infinity.
        """
        self._current_bundle = ray_bundle
        return self._geom.find_intersections(self._temp_frame, ray_bundle)
    
    def get_outgoing(self, selector):
        """
        Generates a new ray bundle, which is the reflections/refractions of the
        user-selected rays out of the incoming ray-bundle that was previously
        registered.
        
        Arguments: 
        selector - a boolean array specifying which rays of the incoming
            bundle are still relevant.
        
        Returns: 
        a RayBundle object with the new bundle, with vertices on the surface
            and directions according to optics laws.
        """
        return self._opt(self._geom, self._current_bundle, selector)

