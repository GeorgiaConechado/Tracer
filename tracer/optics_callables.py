# A collection of callables and tools for creating them, that may be used for
# the optics-callable part of a Surface object.

import optics
import ray_bundle
import numpy as N

def gen_reflective(absorptivity):
    """
    Generates a function that represents the optics of an opaque, absorptive
    surface with specular reflections.
    
    Arguments:
    absorptivity - the amount of energy absorbed before reflection.
    
    Returns:
    refractive - a function with the signature required by Surface.
    """
    def reflective(geometry, rays, selector):
        outg = ray_bundle.RayBundle()
        outg.set_vertices(geometry.get_intersection_points_global(selector))
        outg.set_directions(optics.reflections(
            rays.get_directions()[:,selector],
            geometry.get_normals(selector)))
        outg.set_energy(rays.get_energy()[selector]*(1 - absorptivity))
        outg.set_parent(N.where(selector)[0]) # Each ray is reflected in order
        # Moving in the same medium, no change of ref_index
        outg.set_ref_index(rays.get_ref_index()[selector])
        return outg
    return reflective

perfect_mirror = gen_reflective(0)

class ReflectiveReceiver(object):
    def __init__(self, absorptivity=1.):
        self._abs = absorptivity
        self._new_ray_bundle = gen_reflective(self._abs)
        self._absorbed = []
        self._hits = []
    
    def __call__(self, geometry, rays, selector):
        self._absorbed.append(rays.get_energy()[selector]*self._abs)
        self._hits.append(geometry.get_intersection_points_global(selector))
        return self._new_ray_bundle(geometry, rays, selector)
    
    def get_all_hits(self):
        """
        Aggregate all hits from all stages of tracing into joined arrays.
        
        Returns:
        absorbed - the energy absorbed by each hit-point
        hits - the corresponding global coordinates for each hit-point.
        """
        if not len(self._absorbed):
            return N.array([]), N.array([]).reshape(3,0)
        
        return N.hstack([a for a in self._absorbed if len(a)]), \
            N.hstack([h for h in self._hits if h.shape[1]])

class RefractiveHomogenous(object):
    """
    Represents the optics of a surface bordering homogenous media with 
    constant refractive index on each side. The specific index in which a
    refracted ray moves is determined by toggling between the two possible
    indices.
    """
    def __init__(self, n1, n2):
        """
        Arguments:
        n1, n2 - scalars representing the homogenous refractive index on each
            side of the surface (order doesn't matter).
        """
        self._ref_idxs = (n1, n2)
    
    def toggle_ref_idx(self, current):
        """
        Determines which refractive index to use based on the refractive index
        rays are currently travelling through.

        Arguments:
        current - an array of the refractive indices of the materials each of 
            the rays in a ray bundle is travelling through.
        
        Returns:
        An array of length(n) with the index to use for each ray.
        """
        return N.where(current == self._ref_idxs[0], 
            self._ref_idxs[1], self._ref_idxs[0])
    
    def __call__(self, geometry, rays, selector):
        if not selector.any():
            return ray_bundle.empty_bund()
        
        n1 = rays.get_ref_index()[selector]
        n2 = self.toggle_ref_idx(n1)
        refr, out_dirs = optics.refractions(n1, n2, \
            rays.get_directions()[:,selector], geometry.get_normals(selector))
        
        if not refr.any():
            return perfect_mirror(geometry, rays, selector)
        
        # The output bundle is generated by stacking together the reflected and
        # refracted rays in that order.
        outg = ray_bundle.RayBundle()
        inters = geometry.get_intersection_points_global(selector)
        outg.set_vertices(N.hstack((inters, inters[:,refr])))
        
        outg.set_directions(N.hstack(
            (optics.reflections(
                rays.get_directions()[:,selector],
                geometry.get_normals(selector)),
            out_dirs)))
        
        # Energy:
        R = N.ones(selector.sum())
        R[refr] = optics.fresnel(rays.get_directions()[:,selector],
            geometry.get_normals(selector), n1, n2)
        reflect_en = rays.get_energy()[selector]*R
        refract_en = rays.get_energy()[selector][refr]*(1 - R[refr])
        outg.set_energy(N.hstack((reflect_en, refract_en)))
        
        # Parents:
        full_p = N.where(selector)[0]
        outg.set_parent(N.hstack((full_p, full_p[refr]))) # Each ray is reflected in order
        # Refractive index:
        outg.set_ref_index(N.hstack((n1, n2[refr])))
        
        return outg
